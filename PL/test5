(define (jobs_ok? x y)
	(cond())

(define (jobs_ok? x)
	;checks for duplicates
	(check_rows? x x)

		
(define current_rows? x y)
	;checks for duplicates in current row
	;x = whole x anchor value
	;y = copy of x to increment
	;Base Case: Reached end of row with no duplicates: return true
	;Recursion: Finished checking one element: recurse for next element
	;			No match: compare with the cadr of y
	
	(cond((null? (cdr x)) (other_row_good? (x y)) ;anchor value reached end of row. Check other rows
		 ((null? (cdr y) (current_row_good?((cadr x) (cddr y))) ;one wave is done check next element
		 ((equal? (car x) (cadr y)) #F) ; match = duplicate 
		 (else (current_row_good? ((car x) (cdr y)))))

		
(define other_row_good? x y)
	;checks for duplicates in other rows
	;x = value to compare from
	;y = comparison value increment
	
	(cond((null? (cdr x)) #T) ;anchor value reached end return true no duplicates
		 ((null? (cdr y) current_row_good?((cadr x) (cddr y))) ;one wave is done check next element
		 ((equal? (car x) (cadr y)) #F) 
		 (else (current_row_good? ((car x) (cdr y)))))
	
	
	(null? car x) other_row_good?((cdr x) (cdr x)))
		 ((equal? (car x) (cadr x)) #F)
		 	other_row_good? (cdr x)



(jobs_ok?
   '(
	(Park Dunbar Knox Lloyd)
	(Brown Trivedi Ramos Franklin)
	(Schmidt Nakamura Adams Chen)
	(Evans Goldberg Macmillan Quincy))
   '(
	(Adams 1 1 1)
	(Brown 1 1 1)
	(Chen 1 1 1)
	(Dunbar 1 1 1)
	(Evans 1 1 1)
	(Franklin 1 1 1)
	(Goldberg 1 1 1)
	(Jefferson 1 1 1)
	(Knox 1 1 1)
	(Lloyd 1 1 1)
	(Macmillan 1 1 1)
	(Nakamura 1 1 1)
	(Park 1 1 1)
	(Quincy 1 1 1)
	(Ramos 1 1 1)
	(Schmidt 1 1 1)
	(Trivedi 1 1 1)))